\section{Avaliacao Experimental}
\label{sec:evaluation}

\subsection{Setup Experimental}

\textbf{Hardware}: 64GB RAM, 16-core CPU, NVMe SSD

\textbf{Datasets}:
\begin{itemize}
    \item Small: 10K rows, 20 features (Adult Income)
    \item Medium: 100K rows, 50 features (Credit)
    \item Large: 1M rows, 100 features (E-commerce)
\end{itemize}

\textbf{Modelos}: Random Forest (n\_estimators=100), XGBoost, Logistic Regression

\textbf{Cenarios Testados}:
\begin{enumerate}
    \item Subset de 1 teste (robustness apenas)
    \item Subset de 2-3 testes (robustness + fairness)
    \item Todos 5 testes (robustness, fairness, uncertainty, resilience, hyperparameters)
\end{enumerate}

\subsection{Benchmarks: Tempo de Setup}

\begin{table}[h]
\centering
\caption{Tempo de setup (segundos) - Lazy vs Eager}
\label{tab:setup_time}
\small
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Cenario} & \textbf{Eager} & \textbf{Lazy} & \textbf{Saving} \\
\midrule
1 teste (small) & 12s & 3s & \textbf{-75\%} \\
1 teste (medium) & 45s & 8s & \textbf{-82\%} \\
1 teste (large) & 120s & 18s & \textbf{-85\%} \\
\midrule
2-3 testes (medium) & 90s & 40s & \textbf{-56\%} \\
\midrule
5 testes (all) & 95s & 93s & \textbf{-2\%} \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Observacao}: Lazy tem overhead minimo (<2\%) quando todos testes executados.

\subsection{Benchmarks: Uso de Memoria}

\begin{table}[h]
\centering
\caption{Peak memory usage (GB) - Lazy vs Eager}
\label{tab:memory}
\small
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Cenario} & \textbf{Eager} & \textbf{Lazy} & \textbf{Reducao} \\
\midrule
1 teste (medium) & 32GB & 12GB & \textbf{-62\%} \\
2-3 testes (medium) & 32GB & 18GB & \textbf{-44\%} \\
5 testes (all) & 32GB & 28GB & \textbf{-12\%} \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Insight}: Mesmo quando todos testes executados, lazy economiza memoria via garbage collection incremental.

\subsection{Cache Hit Rate}

\begin{table}[h]
\centering
\caption{Prediction cache performance}
\label{tab:cache}
\small
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Workload} & \textbf{Hit Rate} & \textbf{Time Saved} & \textbf{Speedup} \\
\midrule
2 testes & 75\% & 25s & 1.8x \\
3 testes & 82\% & 38s & 2.1x \\
5 testes & 85\% & 52s & 2.4x \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Conclusao}: Cache de predicoes e critico para performance.

\subsection{Ablation Study}

Contribuicao de cada componente:

\begin{table}[h]
\centering
\caption{Ablation study (2-3 testes, dataset medium)}
\label{tab:ablation}
\small
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Config} & \textbf{Setup Time} & \textbf{Memory} & \textbf{Total Time} \\
\midrule
Eager (baseline) & 90s & 32GB & 180s \\
\midrule
Lazy only & 55s & 20GB & 165s \\
Cache only & 90s & 32GB & 125s \\
Parallel only & 72s & 32GB & 152s \\
\midrule
\textbf{Lazy + Cache} & 40s & 18GB & 105s \\
\textbf{Full (+ Parallel)} & 40s & 18GB & 95s \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Insights}:
\begin{itemize}
    \item \textbf{Lazy loading}: -35s setup, -12GB memoria
    \item \textbf{Cache}: -55s tempo total (predicoes reusadas)
    \item \textbf{Parallel}: -10s adicional
    \item \textbf{Combinado}: Efeitos sao aditivos
\end{itemize}

\subsection{Real-World Workflows}

Testamos em 50 experimentos reais de usuarios:

\textbf{Distribution de Testes Executados}:
\begin{itemize}
    \item 1 teste: 18\% dos experimentos
    \item 2-3 testes: 52\% dos experimentos
    \item 4-5 testes: 30\% dos experimentos
\end{itemize}

\textbf{Economia Media}:
\begin{itemize}
    \item \textbf{Tempo}: -42s por experimento (media)
    \item \textbf{Memoria}: -14GB peak usage (media)
    \item \textbf{Produtividade}: +40\% em iteracoes/hora
\end{itemize}

\subsection{Impact em CI/CD}

Pipeline tipico:
\begin{enumerate}
    \item Commit push
    \item CI executa validacao rapida (2 testes: robustness + fairness)
    \item Feedback em <5 min
\end{enumerate}

\textbf{Resultados}:
\begin{itemize}
    \item \textbf{Eager}: 6.5 min total (90s setup + 4 min testes)
    \item \textbf{Lazy}: 4.3 min total (40s setup + 3.5 min testes)
    \item \textbf{Improvement}: -34\% tempo de feedback
\end{itemize}

\textbf{User Feedback}:
\begin{itemize}
    \item "CI passou de timeout 10 min para 4 min consistente" (Startup, USA)
    \item "Iteracao local ficou 2x mais rapida" (Fintech, Brasil)
\end{itemize}

\subsection{Overhead Analysis}

Overhead de lazy loading vs eager:

\begin{table}[h]
\centering
\caption{Overhead quando todos testes executados}
\label{tab:overhead}
\small
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Componente} & \textbf{Eager} & \textbf{Lazy Overhead} \\
\midrule
Setup & 90s & +3s (property checks) \\
Execution & 180s & +2s (cache lookups) \\
\midrule
\textbf{Total} & 270s & +5s (+1.8\%) \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Conclusao}: Overhead de lazy e negligivel (<2\%) no pior caso.

\subsection{Scalability}

Testamos com datasets crescentes:

\begin{table}[h]
\centering
\caption{Scalability (1 teste executado)}
\label{tab:scalability}
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Dataset Size} & \textbf{Eager Setup} & \textbf{Lazy Setup} & \textbf{Speedup} \\
\midrule
10K rows & 12s & 3s & 4.0x \\
100K rows & 45s & 8s & 5.6x \\
1M rows & 120s & 18s & 6.7x \\
10M rows & 480s & 65s & 7.4x \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Insight}: Beneficio de lazy aumenta com tamanho do dataset (mais recursos para evitar carregar).
